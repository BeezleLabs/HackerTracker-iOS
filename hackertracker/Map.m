//
//  Map.m
//  Map
//
//  Created by Chris on 6/1/17.
//  Copyright Â© 2017 Def Con. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//

#import "Map.h"


@implementation Map

#pragma mark Initialization

+ (void)initialize
{
}

#pragma mark Drawing Methods

+ (void)drawCanvas1
{
    [Map drawCanvas1WithFrame: CGRectMake(0, 0, 668, 668) resizing: MapResizingBehaviorStretch];
}

+ (void)drawCanvas1WithFrame: (CGRect)targetFrame resizing: (MapResizingBehavior)resizing
{
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();
    
    //// Resize to Target Frame
    CGContextSaveGState(context);
    CGRect resizedFrame = MapResizingBehaviorApply(resizing, CGRectMake(0, 0, 668, 668), targetFrame);
    CGContextTranslateCTM(context, resizedFrame.origin.x, resizedFrame.origin.y);
    CGContextScaleCTM(context, resizedFrame.size.width / 618, resizedFrame.size.height / 618);

    
    //// Color Declarations
    UIColor* color = [UIColor colorWithRed: 0.86 green: 0.277 blue: 0.277 alpha: 0];

    //// Upper Gray Layer Drawing
    UIBezierPath* upperGrayLayerPath = [UIBezierPath bezierPath];
    [upperGrayLayerPath moveToPoint: CGPointMake(42, 251)];
    [upperGrayLayerPath addLineToPoint: CGPointMake(93, 251)];
    [upperGrayLayerPath addLineToPoint: CGPointMake(93, 225)];
    [upperGrayLayerPath addLineToPoint: CGPointMake(570, 225)];
    [upperGrayLayerPath addLineToPoint: CGPointMake(570, 204)];
    [upperGrayLayerPath addLineToPoint: CGPointMake(606, 204)];
    [upperGrayLayerPath addLineToPoint: CGPointMake(606, 187)];
    [upperGrayLayerPath addLineToPoint: CGPointMake(575, 187)];
    [upperGrayLayerPath addLineToPoint: CGPointMake(575, 163)];
    [upperGrayLayerPath addLineToPoint: CGPointMake(614, 163)];
    [upperGrayLayerPath addLineToPoint: CGPointMake(614, 113)];
    [upperGrayLayerPath addLineToPoint: CGPointMake(530, 113)];
    [upperGrayLayerPath addLineToPoint: CGPointMake(530, 82)];
    [upperGrayLayerPath addLineToPoint: CGPointMake(325, 81)];
    [upperGrayLayerPath addLineToPoint: CGPointMake(42, 156)];
    [upperGrayLayerPath addLineToPoint: CGPointMake(42, 251)];
    [upperGrayLayerPath closePath];
    [UIColor.lightGrayColor setFill];
    [upperGrayLayerPath fill];
    [UIColor.blackColor setStroke];
    upperGrayLayerPath.lineWidth = 0.5;
    [upperGrayLayerPath stroke];


    //// Pool Level Border Drawing
    UIBezierPath* poolLevelBorderPath = [UIBezierPath bezierPath];
    [poolLevelBorderPath moveToPoint: CGPointMake(41.5, 594.5)];
    [poolLevelBorderPath addLineToPoint: CGPointMake(173.5, 594.5)];
    [poolLevelBorderPath addLineToPoint: CGPointMake(173.5, 625.5)];
    [poolLevelBorderPath addLineToPoint: CGPointMake(383.5, 625.5)];
    [poolLevelBorderPath addLineToPoint: CGPointMake(383.5, 594.5)];
    [poolLevelBorderPath addLineToPoint: CGPointMake(546.5, 594.5)];
    [poolLevelBorderPath addLineToPoint: CGPointMake(546.5, 625.5)];
    [poolLevelBorderPath addLineToPoint: CGPointMake(616.5, 625.5)];
    [poolLevelBorderPath addLineToPoint: CGPointMake(616.5, 112.5)];
    [poolLevelBorderPath addLineToPoint: CGPointMake(531.5, 112.5)];
    [poolLevelBorderPath addLineToPoint: CGPointMake(531.5, 81.5)];
    [poolLevelBorderPath addLineToPoint: CGPointMake(324.5, 81.5)];
    [poolLevelBorderPath addLineToPoint: CGPointMake(41.5, 156.5)];
    [poolLevelBorderPath addLineToPoint: CGPointMake(41.5, 594.5)];
    [poolLevelBorderPath closePath];
    [color setFill];
    [poolLevelBorderPath fill];
    [UIColor.blackColor setStroke];
    poolLevelBorderPath.lineWidth = 6;
    poolLevelBorderPath.lineJoinStyle = kCGLineJoinRound;
    [poolLevelBorderPath stroke];
    
    CGContextRestoreGState(context);

}

@end



CGRect MapResizingBehaviorApply(MapResizingBehavior behavior, CGRect rect, CGRect target)
{
    if (CGRectEqualToRect(rect, target) || CGRectEqualToRect(target, CGRectZero))
        return rect;

    CGSize scales = CGSizeZero;
    scales.width = ABS(target.size.width / rect.size.width);
    scales.height = ABS(target.size.height / rect.size.height);

    switch (behavior)
    {
        case MapResizingBehaviorAspectFit:
        {
            scales.width = MIN(scales.width, scales.height);
            scales.height = scales.width;
            break;
        }
        case MapResizingBehaviorAspectFill:
        {
            scales.width = MAX(scales.width, scales.height);
            scales.height = scales.width;
            break;
        }
        case MapResizingBehaviorStretch:
            break;
        case MapResizingBehaviorCenter:
        {
            scales.width = 1;
            scales.height = 1;
            break;
        }
    }

    CGRect result = CGRectStandardize(rect);
    result.size.width *= scales.width;
    result.size.height *= scales.height;
    result.origin.x = target.origin.x + (target.size.width - result.size.width) / 2;
    result.origin.y = target.origin.y + (target.size.height - result.size.height) / 2;
    return result;
}
